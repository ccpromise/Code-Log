About algorithm:

1\ sort:
	insertion bubble selection
	quick merge heap

    improvement: 3way quicksort for duplicate items, iteration merge sort, mergesort already sort    
    complexity: quicksort O(1) space, not stable
    			mergesort O(N) space, stable
    			heapsort O(1) space, not stable
    complexity analysis: quicksort and mergesort
    
2\ Graph:
	2.1 Undirected Graph	
	 single dfs: given G and s, is v connected to s?
	 multiple dfs: given G, is s connected to v? How many components? Compare to 				Union Find, which is also about connectivity.
	 from dfs to bfs: given G and s, is s hasPathTo v?  
	 Proof bfs able to find the shortest path by induction.
	 When we come to a point that has more than one edges to explore, we choose one and save others to explore later. DFS use stack. BFS use heap. Stack is easier to implement by function frames(recursion) because function frames save environment. DFS path is long and winding. BFS is short and direct.
	2.2 Directed Graph
		Cycle_detection Topological_order(BFS, DFS)
	2.3 Undirected Weighted Graph
		Min_spanning_tree
	2.4 Directed Weighted Graph
		Min_path
		
3\ map:
	3.1 binary search tree
		insert, delete, query, rank
	3.2 hash table	
		collision_dealing