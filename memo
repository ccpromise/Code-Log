#354 Russain Doll Envelopes
1) when you encounter some problems, first think about is there any way to walk around it. If not, try to solve it directly.
2) 1. divide and conquer -> what is the longest increasing sequence ending with ith element?
   2. dp -> if we already have an increasing sequence like 1,3,6,7,9, what if the next number we meet is 3, 4, 8, 10?
3) examplify some problems so that you can find a clue.

#297 Serialize and Deserialize Binary Tree
	Decouple your solution. Make it modular so that keep your solution in a clear way.

#115 Distinct Subsequence
	recursion is trivail: but still need improvement to avoid unnecessary recursion.
	iteration: build a map for two string problem. map[m, n] how it connects to map[m-1,n], map[m-1,n-1], map[m, n-1]
	Similar problem: longest common subsequence.

#363 Max Sum of Rectangle No Larger Than K
The maximum subarray sum:
	1)divide and conquer: what is the maximum subarray sum ending with i-th element? cum[i] = Math.Max(cum[i-1]+arr[i], arr[i])
	2)sum[i, j] = sum[j]-sum[i];
		cum += arr[i];
		ret = Math.Max(ret, cum-min_cum);
		min_cum = Math.Min(min_cum, cum); // min_cum initialize to be 0.
		subarray sum is sum[j]-sum[i]. Suppose we already have sum[0], sum[1], ..., sum[i-1]. Now we have sum[i], we only need to subtract sum[i] using the smallest number in the set.
The maximum subarray sum no more than k:
	store cum[] in a set, for a new cum: find lower_bound of cum-k, ret = Math.Max(ret, cum-*lower_bound). Insert cum into set.
	This is actually implemented by BST-> To find a min number in a set more than k. Use BST, O(lgN)
	subarray sum is sum[j]-sum[i]. Suppose we already have s = {sum[0], sum[1], ..., sum[i-1]}. Now we have sum[i], we need to find a number x in s, so that sum[i]-x <= k, e.g x >= sum[i]-k. x is the smallest number bigger than sum[i]-k in set s. So we use BST to store the set so that we can find x fast.
	similar problem: count numbers smaller than self in the right		
THe maximum sub-matrix:
	1) For each row i, calculate the sum of l-th col to r-th col elements. For each i, apply one-D solution. THe complexity should be O(n^2*m): n is smaller one of # rows and cols.
The maximum sub-matrix no more than k:
	sum[i, j]=the first i element of column j. For each i, apply one-D solution.The complexity should be O(n^2*m*lgm)

What is the optimal subsequence in a sequence?
1) what is the optimal subsequence containing ith element / containing ith element as the biggest value / ...
2) if we already have a optimal subsequence like X, X, X, X, what if our next number is A,B, C, D, ....? How to adapt the optimal subsequence.